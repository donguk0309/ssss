import hashlib
from io import BytesIO
import tkinter as tk
from tkinter import filedialog, messagebox, Listbox, Scrollbar
import serial  # ì•„ë‘ì´ë…¸ í†µì‹ ìš©

# â–£ ì•„ë‘ì´ë…¸ì™€ì˜ ì‹œë¦¬ì–¼ ë¸Œë¦¿ì§€
class ArduinoBridge:
    def __init__(self, port='COM3', baudrate=9600):  # â— í¬íŠ¸ ë³€ê²½ í•„ìš”
        self.ser = serial.Serial(port, baudrate, timeout=2)

    def send_file(self, name, seed_hash, size):
        name_bytes = name.encode('utf-8')[:32].ljust(32, b'\x00')
        hash_bytes = bytes.fromhex(seed_hash)
        size_bytes = size.to_bytes(4, 'big')
        payload = name_bytes + hash_bytes + size_bytes
        self.ser.write(b'S')  # Save command
        self.ser.write(payload)

    def list_files(self):
        self.ser.reset_input_buffer()
        self.ser.write(b'L')
        files = []
        while self.ser.in_waiting >= 100:
            name = self.ser.read(32).decode('utf-8').rstrip('\x00')
            hash_bytes = self.ser.read(64)
            seed_hash = hash_bytes.hex()
            size = int.from_bytes(self.ser.read(4), 'big')
            files.append((name, seed_hash, size))
        return files

    def clear(self):
        self.ser.write(b'C')


# â–£ ìˆ˜ì‹ ê¸°ë°˜ ê°€ìƒ YB íŒŒì¼
class VirtualYBFile:
    def __init__(self, name, seed_hash, size):
        self.name = name
        self.seed_hash = seed_hash
        self.size = size

    def formula(self, i):
        h = hashlib.sha256(f"{self.seed_hash}:{i}".encode()).digest()
        return h[0]  # ì²« ë°”ì´íŠ¸

    def read_range(self, start, end):
        return bytes([self.formula(i) for i in range(start, min(end, self.size))])


# â–£ YB ê°€ìƒ íŒŒì¼ ì‹œìŠ¤í…œ + ì•„ë‘ì´ë…¸ ì—°ë™
class YBFileStorage:
    def __init__(self):
        self.files = {}
        self.arduino = ArduinoBridge()  # í¬íŠ¸ ì„¤ì • í•„ìš”

    def create_file(self, name, seed_hash, size):
        self.files[name] = VirtualYBFile(name, seed_hash, size)

    def upload_file(self, file_path):
        with open(file_path, 'rb') as f:
            data = f.read()
        size = len(data)
        seed_hash = hashlib.sha256(data).hexdigest()
        name = file_path.split("/")[-1]
        self.create_file(name, seed_hash, size)
        self.arduino.send_file(name, seed_hash, size)
        return name

    def download_file(self, name):
        file = self.files.get(name)
        if not file:
            return None
        data = file.read_range(0, file.size)
        return BytesIO(data)

    def delete_file(self, name):
        if name in self.files:
            del self.files[name]
            # EEPROMì—ì„œ ì‚­ì œëŠ” í˜„ì¬ ë¯¸ì§€ì› (ì „ì²´ ì´ˆê¸°í™”ë§Œ ê°€ëŠ¥)

    def list_files(self):
        return list(self.files.keys())

    def refresh_from_arduino(self):
        arduino_files = self.arduino.list_files()
        self.files = {}  # ê¸°ì¡´ ìºì‹œ ì´ˆê¸°í™”
        for name, seed_hash, size in arduino_files:
            self.create_file(name, seed_hash, size)


# â–£ GUI ì• í”Œë¦¬ì¼€ì´ì…˜
class YBApp:
    def __init__(self, root):
        self.root = root
        root.title("ğŸ“‚ YB í´ë¼ìš°ë“œ (ì•„ë‘ì´ë…¸ USB ê¸°ë°˜)")

        self.upload_btn = tk.Button(root, text="ğŸ“¤ ì—…ë¡œë“œ", command=self.upload_file)
        self.upload_btn.pack(pady=5)

        self.file_listbox = Listbox(root, width=50)
        self.file_listbox.pack(padx=10, pady=5)

        self.scrollbar = Scrollbar(root)
        self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.file_listbox.config(yscrollcommand=self.scrollbar.set)
        self.scrollbar.config(command=self.file_listbox.yview)

        self.download_btn = tk.Button(root, text="â¬‡ï¸ ë‹¤ìš´ë¡œë“œ", command=self.download_file)
        self.download_btn.pack(pady=2)

        self.delete_btn = tk.Button(root, text="ğŸ—‘ï¸ ì‚­ì œ (ìºì‹œë§Œ)", command=self.delete_file)
        self.delete_btn.pack(pady=2)

        self.refresh_btn = tk.Button(root, text="ğŸ”„ ìƒˆë¡œê³ ì¹¨", command=self.refresh_list)
        self.refresh_btn.pack(pady=2)

        self.refresh_list()

    def refresh_list(self):
        fs.refresh_from_arduino()
        self.file_listbox.delete(0, tk.END)
        for file in fs.list_files():
            self.file_listbox.insert(tk.END, file)

    def upload_file(self):
        path = filedialog.askopenfilename()
        if path:
            name = fs.upload_file(path)
            self.refresh_list()
            messagebox.showinfo("ì—…ë¡œë“œ ì™„ë£Œ", f"{name} ì—…ë¡œë“œ ì„±ê³µ!")

    def download_file(self):
        selected = self.file_listbox.curselection()
        if not selected:
            return
        name = self.file_listbox.get(selected[0])
        save_path = filedialog.asksaveasfilename(initialfile=name)
        if save_path:
            data = fs.download_file(name)
            with open(save_path, 'wb') as f:
                f.write(data.read())
            messagebox.showinfo("ë‹¤ìš´ë¡œë“œ ì™„ë£Œ", f"{name} ì €ì¥ ì™„ë£Œ!")

    def delete_file(self):
        selected = self.file_listbox.curselection()
        if not selected:
            return
        name = self.file_listbox.get(selected[0])
        fs.delete_file(name)
        self.refresh_list()
        messagebox.showinfo("ì‚­ì œ ì™„ë£Œ", f"{name} ìºì‹œ ì‚­ì œ ì™„ë£Œ (EEPROMì€ ìœ ì§€ë¨)")


# â–£ ì‹¤í–‰ ì‹œì‘
if __name__ == '__main__':
    fs = YBFileStorage()
    root = tk.Tk()
    app = YBApp(root)
    root.mainloop()






#include <EEPROM.h>
#include <SoftwareSerial.h>

#define MAX_FILES 5
#define RECORD_SIZE 100  // 64ë°”ì´íŠ¸ í•´ì‹œ + 32ë°”ì´íŠ¸ ì´ë¦„ + 4ë°”ì´íŠ¸ í¬ê¸°

void setup() {
  Serial.begin(9600);
  while (!Serial) {}

  if (Serial.available()) {
    char cmd = Serial.read();
    if (cmd == 'L') listFiles();
    else if (cmd == 'S') saveFile();  // ì „ì†¡ëœ ë°ì´í„° ì €ì¥
  }
}

void loop() {
  if (Serial.available()) {
    char cmd = Serial.read();
    if (cmd == 'L') listFiles();
    else if (cmd == 'S') saveFile();
    else if (cmd == 'C') clearFiles();
  }
}

void listFiles() {
  for (int i = 0; i < MAX_FILES; i++) {
    int base = i * RECORD_SIZE;
    byte first = EEPROM.read(base);
    if (first != 0xFF) {
      // ì´ë¦„
      for (int j = 0; j < 32; j++) {
        char c = EEPROM.read(base + j);
        Serial.write(c);
      }
      // í•´ì‹œ
      for (int j = 32; j < 96; j++) {
        byte b = EEPROM.read(base + j);
        Serial.write(b);
      }
      // í¬ê¸° (4ë°”ì´íŠ¸)
      for (int j = 96; j < 100; j++) {
        byte b = EEPROM.read(base + j);
        Serial.write(b);
      }
    }
  }
}

void saveFile() {
  int slot = -1;
  for (int i = 0; i < MAX_FILES; i++) {
    int base = i * RECORD_SIZE;
    if (EEPROM.read(base) == 0xFF) {
      slot = i;
      break;
    }
  }
  if (slot == -1) return;

  int base = slot * RECORD_SIZE;

  // 32B ì´ë¦„, 64B í•´ì‹œ, 4B í¬ê¸° ìˆ˜ì‹ 
  while (Serial.available() < 100);
  for (int i = 0; i < 100; i++) {
    byte b = Serial.read();
    EEPROM.write(base + i, b);
  }
}

void clearFiles() {
  for (int i = 0; i < MAX_FILES * RECORD_SIZE; i++) {
    EEPROM.write(i, 0xFF);
  }
}
